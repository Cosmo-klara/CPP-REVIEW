# Operator Overloading ( 运算符重载 )

> 时间有限，先写个简单的吧。

为什么我们要重载运算符呢？最直接的，我们需要能够进行对象 ( 用户自建类型 ) 的运算。

这就好像我们重载 print 函数一样，我们能够自定义输出格式。

```cpp
    void print(int i) {
        cout << "整数为: " << i << endl;
    }
    void print(double  f) {
        cout << "浮点数为: " << f << endl;
    }
    void print(char c[]) {
        cout << "字符串为: " << c << endl;
    }
```

可以重载：

| 运算符名称 | 符号 |
|:---:|:---:|
| 双目算术运算符 | + (加)，-(减)，*(乘)，/(除)，% (取模) |
| 关系运算符 | ==(等于)，!= (不等于)，< (小于)，> (大于)，<=(小于等于)，>=(大于等于) |
| 逻辑运算符 | ||(逻辑或)，&&(逻辑与)，!(逻辑非) |
| 单目运算符 | + (正)，-(负)，*(指针)，&(取地址) |
| 自增自减运算符 | ++(自增)，--(自减) |
| 位运算符 | | (按位或)，& (按位与)，~(按位取反)，^(按位异或),，<< (左移)，>>(右移) |
| 赋值运算符 | =, +=, -=, *=, /= , % = , &=, |=, ^=, <<=, >>= |
| 空间申请与释放 | new, delete, new[ ] , delete[] |
| 其他运算符 | () (函数调用)，-> (成员访问)，, (逗号)，[] (下标) |

不能重载：

| 运算符名称 | 符号 |
|:---:|:---:|
| 成员访问运算符 | . |
| 成员指针访问运算符 | .* , ->* |
| 域运算符 | :: |
| 长度运算符 | sizeof |
| 条件运算符 | ? : |
| 预处理符号 | # |

直接上代码吧！

```cpp
    class A{
        int height;
        int width;
    public:
        A(int h = 0, int w = 0) {
            height = h;
            width = w;
        }
        A operator+(const A &x)
        {
            A a;
            a.height = this->height + x.height;
            a.width = this->width + x.width;
            return a;
        }
    }
```